module vyatta-protocols-static-v1 {
	namespace "urn:vyatta.com:mgmt:vyatta-protocols-static:1";
	prefix vyatta-protocols-static-v1;

	import vyatta-types-v1 {
		prefix types;
	}
	import vyatta-protocols-v1 {
		prefix protocols;
	}
	import configd-v1 {
		prefix configd;
	}

	organization "Brocade Communications Systems, Inc.";
	contact
		"Brocade Communications Systems, Inc.
		 Postal: 130 Holger Way
		         San Jose, CA 95134
		 E-mail: support@Brocade.com
		 Web: www.brocade.com";

	description
		"Copyright (c) 2014-2016 by Brocade Communications Systems, Inc.
		 All rights reserved.

		 This module implements vyatta-protocols-static-v1.";

	revision 2016-07-13 {
		description "Removing yang grammar validation for table ipv4 next-hop node";
	}
	revision 2016-06-24 {
		description "Add config priority to static arp";
	}
	revision 2016-05-02 {
		description "Adding yang grammar validation and grouping ipv4/v6 next-hop node";
	}
	revision 2014-08-06 {
		description "Initial revision of version 1";
	}

	grouping static-route-distance {
		leaf distance {
			type uint32 {
				range 1..255;
			}
			configd:help "Distance value for this route";
			description "Distance value for this route";
			default "1";
		}
	}

	grouping static-route-interface {
		leaf interface {
			type string;
			configd:help "Outgoing interface";
			description "Outgoing interface";
			configd:allowed "/opt/vyatta/sbin/vyatta-interfaces.pl --show all ";
		}
	}

	grouping static-route-disable {
		leaf disable {
			type empty;
			configd:help "Disable IPv4 next-hop static route";
			description "Disable IPv4 next-hop static route";
		}
	}		

	// This grouping has dependency on the external route list node referenced via a relative path.
	grouping static-route-ipv4-next-hop {
		list next-hop {
			configd:help "Next-hop router";
			description "Next-hop router";
			must "disable or " +
				"(distance != ../blackhole/distance and " +
				"distance != ../unreachable/distance and " +
				"count(../../interface-route[tagnode = current()/../tagnode]/next-hop-interface[distance = current()/distance]) 
				= count(../../interface-route[tagnode = current()/../tagnode]/next-hop-interface[distance = current()/distance]/disable))" {
					error-message "Must not configure same distance for next-hop, interface-route and blackhole/unreachable";
			}
			configd:end "/opt/vyatta/share/tmplscripts/protocols/static/route/next-hop/configd_end.sh";
			key "tagnode";
			leaf tagnode {
				type types:ipv4-address;
				// Not loopback multicast or broadcast.
				must "(not(starts-with(., '127.'))) and " +
					"((substring-before(., '.') < 224) or " +
					"(substring-before(., '.') >=240)) and " +
					"(not(starts-with(., '255.255.255.255')))" {
						error-message "next-hop shouldn't be a loopback, multicast or broadcast address.";
				}
				configd:help "Next-hop router";
				description "Next-hop router";
			}
			uses static-route-disable;
			uses static-route-interface;
			uses static-route-distance;
		}
	}

	// This grouping has dependency on the external route6 list node referenced via a relative path.
	grouping static-route-ipv6-next-hop {
		list next-hop {
			configd:help "Next-hop IPv6 router";
			description "Next-hop IPv6 router";
			must "disable or " +
				"(distance != ../blackhole/distance and " +
				"distance != ../unreachable/distance and " +
				"count(../../interface-route6[tagnode = current()/../tagnode]/next-hop-interface[distance = current()/distance]) 
				= count(../../interface-route6[tagnode = current()/../tagnode]/next-hop-interface[distance = current()/distance]/disable))" {
					error-message "Must not configure same distance for next-hop, interface-route and blackhole/unreachable";
			}
			configd:end "/opt/vyatta/share/tmplscripts/protocols/static/route6/next-hop/configd_end.sh";
			key "tagnode";
			leaf tagnode {
				type types:ipv6-address;
				// Not multicast loopback or Unspecified.
				must "(not(starts-with(., 'ff'))) and " +
					"(not(. = '::1')) and " +
					"(not(. = '::'))" {
					error-message "next-hop shouldn't be multicast, loopback or unspecified.";
				}
				configd:help "Next-hop IPv6 router";
				description "Next-hop IPv6 router";
			}
			uses static-route-disable;
			uses static-route-interface;
			uses static-route-distance;
		}
	}

	grouping static-route {
		container static {
			presence "true";
			configd:priority "450";
			configd:help "static route parameters";
			list table {
				configd:help "Policy route table number";
				key "tagnode";
				leaf tagnode {
					type uint32 {
						range 1..128 {
							error-message "Table value must be in the range (1-128)";
						}
					}
					configd:help "Policy route table number";
				}
				list route {
					configd:help "Static route";
					must "next-hop or blackhole or unreachable" {
						error-message "Must add either a next-hop or blackhole/unreachable";
					}
					key "tagnode";
					leaf tagnode {
						type types:ipv4-prefix {
							configd:normalize "normalize ipv4-prefix";
						}
						configd:help "Static route";
					}
					list next-hop {
						configd:help "Next-hop router [REQUIRED]";
						must "disable or " + 
							"(distance != ../blackhole/distance and " + 
							"distance != ../unreachable/distance and " +
							"count(../../interface-route[tagnode = current()/../tagnode]/next-hop-interface[distance = current()/distance]) = count(../../interface-route[tagnode = current()/../tagnode]/next-hop-interface[distance = current()/distance]/disable))" {
								error-message "Must not configure same distance for next-hop, interface-route and blackhole/unreachable";
						}
						configd:end "/opt/vyatta/share/tmplscripts/protocols/static/table/route/next-hop/configd_end.sh";
						key "tagnode";
						leaf tagnode {
							type types:ipv4-address;
							configd:help "Next-hop router [REQUIRED]";
						}
						leaf disable {
							type empty;
							configd:help "Disable IPv4 next-hop static route";
						}
						leaf interface {
							type string;
							configd:help "Outgoing interface";
							configd:allowed "/opt/vyatta/sbin/vyatta-interfaces.pl --show all";
						}
						uses static-route-distance;
					}
					container blackhole {
						presence "true";
						configd:help "Silently discard pkts when matched";
						must "not(../unreachable)" {
							error-message "Must not configure both blackhole and unreachable";
						}
						configd:end "/opt/vyatta/share/tmplscripts/protocols/static/table/route/blackhole/configd_end.sh";
						uses static-route-distance;
					}
					container unreachable {
						presence "Indicates an unreachable route";
						configd:help "Discard packets with ICMP unreachable";
						configd:end "/opt/vyatta/share/tmplscripts/protocols/static/table/route/unreachable/configd_end.sh";
						uses static-route-distance;
					}
				}
				list route6 {
					configd:help "Static IPv6 route";
					must "next-hop or blackhole or unreachable" {
						error-message "Must add either a next-hop or blackhole/unreachable";
					}
					key "tagnode";
					leaf tagnode {
						type types:ipv6-prefix {
							configd:normalize "normalize ipv6-prefix";
						}
						configd:help "Static IPv6 route";
					}
					list next-hop {
						configd:help "Next-hop IPv6 router [REQUIRED]";
						must "disable or " + 
							"(distance != ../blackhole/distance and " + 
							"distance != ../unreachable/distance and " +
							"count(../../interface-route6[tagnode = current()/../tagnode]/next-hop-interface[distance = current()/distance]) = count(../../interface-route6[tagnode = current()/../tagnode]/next-hop-interface[distance = current()/distance]/disable))" {
								error-message "Must not configure the same distance for next-hop, interface-route6 and blackhole/unreachable";
						}
						configd:end "/opt/vyatta/share/tmplscripts/protocols/static/table/route6/next-hop/configd_end.sh";
						key "tagnode";
						leaf tagnode {
							type types:ipv6-address; 
							// Not multicast loopback or Unspecified.
							 must "(not(starts-with(., 'ff'))) and " +
								"(not(. = '::1')) and " +
								"(not(. = '::'))" {
								error-message "next-hop shouldn't be multicast, loopback or unspecified address.";
							}
							configd:help "Next-hop IPv6 router [REQUIRED]";
						}
						leaf disable {
							type empty;
							configd:help "Disable IPv6 next-hop static route";
						}
						leaf interface {
							type string;
							configd:help "Outgoing interface";
							configd:allowed "/opt/vyatta/sbin/vyatta-interfaces.pl --show all";
						}
						uses static-route-distance;
					}
					container blackhole {
						presence "true";
						configd:help "Silently discard pkts when matched";
						must "not(../unreachable)" {
							error-message "Must not configure both blackhole and unreachable";
						}
						configd:end "/opt/vyatta/share/tmplscripts/protocols/static/table/route6/blackhole/configd_end.sh";
						uses static-route-distance;
					}
					container unreachable {
						presence "Indicates an unreachable route";
						configd:help "Discard packets with ICMP unreachable";
						configd:end "/opt/vyatta/share/tmplscripts/protocols/static/table/route6/unreachable/configd_end.sh";
						uses static-route-distance;
					}
				}
				list interface-route {
					configd:help "Interface based static route";
					must "next-hop-interface" {
						error-message "Must add a next-hop-interface";
					}
					key "tagnode";
					leaf tagnode {
						type types:ipv4-prefix {
							configd:normalize "normalize ipv4-prefix";
						}
						configd:help "Interface based static route";
					}
					list next-hop-interface {
						configd:help "Next-hop interface [REQUIRED]";
						must "disable or " +
							"(distance != ../../route[tagnode = current()/../tagnode]/blackhole/distance and " +
							"distance != ../../route[tagnode = current()/../tagnode]/unreachable/distance)" {
								error-message "Must not configure same distance for interface-route and blackhole/unreachable";
						}
						configd:allowed "/opt/vyatta/share/tmplscripts/protocols/static/table/interface-route/next-hop-interface/configd_allowed.sh";
						configd:end "/opt/vyatta/share/tmplscripts/protocols/static/table/interface-route/next-hop-interface/configd_end.sh";
						key "tagnode";
						leaf tagnode {
							type types:interface-ifname;
							configd:help "Next-hop interface [REQUIRED]";
							configd:allowed "/opt/vyatta/share/tmplscripts/protocols/static/table/interface-route/next-hop-interface/configd_allowed.sh";
						}
						leaf disable {
							type empty;
							configd:help "Disable IPv4 interface static route";
						}
						uses static-route-distance;
					}
				}
				list interface-route6 {
					configd:help "Interface based static route";
					must "next-hop-interface" {
						error-message "Must add a next-hop-interface";
					}
					key "tagnode";
					leaf tagnode {
						type types:ipv6-prefix {
							configd:normalize "normalize ipv6-prefix";
						}
						configd:help "Interface based static route";
					}
					list next-hop-interface {
						configd:help "Next-hop interface [REQUIRED]";
						must "disable or " +
							"(distance != ../../route6[tagnode = current()/../tagnode]/blackhole/distance and " +
							"distance != ../../route6[tagnode = current()/../tagnode]/unreachable/distance)" {
								error-message "Must not configure same distance for interface-route and blackhole/unreachable";
						}
						configd:allowed "/opt/vyatta/share/tmplscripts/protocols/static/table/interface-route6/next-hop-interface/configd_allowed.sh";
						configd:end "/opt/vyatta/share/tmplscripts/protocols/static/table/interface-route6/next-hop-interface/configd_end.sh";
						key "tagnode";
						leaf tagnode {
							type types:interface-ifname;
							configd:help "Next-hop interface [REQUIRED]";
							configd:allowed "/opt/vyatta/share/tmplscripts/protocols/static/table/interface-route6/next-hop-interface/configd_allowed.sh";
						}
						leaf disable {
							type empty;
							configd:help "Disable IPv6 interface static route";
						}
						uses static-route-distance;
					}
				}

			}
			// route node has a dependency on next-hop/blackhole/unreachable/next-hop-routing-instance child node.
			// One of the above mentioned child nodes must be configured for it to be a valid configuration.
			// Any new node addition inside the route node will break the dependency.
			list route {
				configd:help "Static route";
				must "count(./*) > 1" {
					error-message "Must add either a next-hop or blackhole/unreachable.";
				}
				key "tagnode";
				leaf tagnode {
					type types:ipv4-prefix {
						configd:normalize "normalize ipv4-prefix";
					}
					configd:help "Static route";
				}
				uses static-route-ipv4-next-hop;
				container blackhole {
					presence "Indicates a blackhole route";
					configd:help "Silently discard pkts when matched";
					must "not(../unreachable)" {
						error-message "Must not configure both blackhole and unreachable";
					}
					configd:end "/opt/vyatta/share/tmplscripts/protocols/static/route/blackhole/configd_end.sh";
					uses static-route-distance;
				}
				container unreachable {
					presence "Indicates an unreachable route";
					configd:help "Discard packets with ICMP unreachable";
					configd:end "/opt/vyatta/share/tmplscripts/protocols/static/route/unreachable/configd_end.sh";
					uses static-route-distance;
				}
			}
			list arp {
				configd:priority "525";
				configd:help "Static ARP translation";
				configd:end "/opt/vyatta/share/tmplscripts/protocols/static/arp/configd_end.sh";
				key "tagnode";
				leaf tagnode {
					type types:ipv4-address;
					configd:help "Static ARP translation";
				}
				leaf hwaddr {
					mandatory true;
					type types:mac-address;
					configd:help "Hardware protocol (e.g. MAC) address to translate to";
				}
				leaf interface {
					mandatory true;
					type string;
					configd:help "Outgoing interface";
					configd:allowed "/opt/vyatta/share/tmplscripts/protocols/static/arp/interface/configd_allowed.sh";
				}
			}
			// route node has a dependency on next-hop/blackhole/unreachable/next-hop-routing-instance child node.
			// One of the above mentioned child nodes must be configured for it to be a valid configuration.
			// Any new node addition inside the route node will break the dependency.
			list route6 {
				configd:help "Static IPv6 route";
				must "count(./*) > 1" {
					error-message "Must add either a next-hop or blackhole/unreachable.";
				}
				key "tagnode";
				leaf tagnode {
					type types:ipv6-prefix {
						configd:normalize "normalize ipv6-prefix";
					}
					configd:help "Static IPv6 route";
					description "Static IPv6 route";
				}
				uses static-route-ipv6-next-hop;
				container blackhole {
					presence "Indicates a blackhole route";
					configd:help "Silently discard pkts when matched";
					must "not(../unreachable)" {
						error-message "Must not configure both blackhole and unreachable";
					}
					configd:end "/opt/vyatta/share/tmplscripts/protocols/static/route6/blackhole/configd_end.sh";
					uses static-route-distance;
				}
				container unreachable {
					presence "Indicates an unreachable route";
					configd:help "Discard packets with ICMP unreachable";
					configd:end "/opt/vyatta/share/tmplscripts/protocols/static/route6/unreachable/configd_end.sh";
					uses static-route-distance;
				}
			}
			list interface-route {
				configd:help "Interface based static route";
				must "next-hop-interface" {
					error-message "Must add a next-hop-interface";
				}
				key "tagnode";
				leaf tagnode {
					type types:ipv4-prefix {
						configd:normalize "normalize ipv4-prefix";
					}
					configd:help "Interface based static route";
				}
				list next-hop-interface {
					configd:help "Next-hop interface [REQUIRED]";
					must "disable or " +
						"(distance != ../../route[tagnode = current()/../tagnode]/blackhole/distance and " +
						"distance != ../../route[tagnode = current()/../tagnode]/unreachable/distance)" {
							error-message "Must not configure same distance for interface-route and blackhole/unreachable";
					}
					configd:allowed "/opt/vyatta/share/tmplscripts/protocols/static/interface-route/next-hop-interface/configd_allowed.sh";
					configd:end "/opt/vyatta/share/tmplscripts/protocols/static/interface-route/next-hop-interface/configd_end.sh";
					key "tagnode";
					leaf tagnode {
						type types:interface-ifname;
						configd:help "Next-hop interface [REQUIRED]";
						configd:allowed "/opt/vyatta/share/tmplscripts/protocols/static/interface-route/next-hop-interface/configd_allowed.sh";
					}
					leaf disable {
						type empty;
						configd:help "Disable IPv4 interface static route";
					}
					uses static-route-distance;
				}
			}
			list interface-route6 {
				configd:help "Interface based IPv6 static route";
				must "next-hop-interface" {
					error-message "Must add a next-hop-interface";
				}	
				key "tagnode";
				leaf tagnode {
					type types:ipv6-prefix {
						configd:normalize "normalize ipv6-prefix";
					}
					configd:help "Interface based IPv6 static route";
				}
				list next-hop-interface {
					configd:help "Next-hop interface [REQUIRED]";
					must "disable or " +
						"(distance != ../../route6[tagnode = current()/../tagnode]/blackhole/distance and " +
						"distance != ../../route6[tagnode = current()/../tagnode]/unreachable/distance)" {
							error-message "Must not configure same distance for interface-route and blackhole/unreachable";
					}
					configd:allowed "/opt/vyatta/share/tmplscripts/protocols/static/interface-route6/next-hop-interface/configd_allowed.sh";
					configd:end "/opt/vyatta/share/tmplscripts/protocols/static/interface-route6/next-hop-interface/configd_end.sh";
					key "tagnode";
					leaf tagnode {
						type types:interface-ifname;
						configd:help "Next-hop interface [REQUIRED]";
						configd:allowed "/opt/vyatta/share/tmplscripts/protocols/static/interface-route6/next-hop-interface/configd_allowed.sh";
					}
					leaf disable {
						type empty;
						configd:help "Disable IPv6 interface static route";
					}
					uses static-route-distance;
				}
			}
		}
	}

	augment /protocols:protocols {
		uses static-route; 
	}
}
